ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"stm32f1xx_hal_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.PWR_OverloadWfe,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  23              	PWR_OverloadWfe:
  24              	.LFB65:
  25              		.file 1 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c"
   1:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
   2:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
   3:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @file    stm32f1xx_hal_pwr.c
   4:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @author  MCD Application Team
   5:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
   7:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   8:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   9:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
  10:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           + Peripheral Control functions 
  11:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  12:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  13:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @attention
  14:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  15:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
  16:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  17:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  18:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  19:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * the "License"; You may not use this file except in compliance with the
  20:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * License. You may obtain a copy of the License at:
  21:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *                        opensource.org/licenses/BSD-3-Clause
  22:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
  23:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  24:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  25:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  26:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  27:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #include "stm32f1xx_hal.h"
  28:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  29:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @addtogroup STM32F1xx_HAL_Driver
  30:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  31:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  32:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  33:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR PWR
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 2


  34:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief    PWR HAL module driver
  35:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  36:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  37:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  38:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  39:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  40:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  41:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  42:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  43:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Constants PWR Private Constants
  44:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  45:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  46:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
  47:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  48:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  49:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */ 
  50:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_IT               0x00010000U
  51:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_EVT              0x00020000U
  52:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_RISING_EDGE           0x00000001U
  53:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVD_FALLING_EDGE          0x00000002U
  54:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  55:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  56:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  57:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  58:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  59:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_register_alias_address PWR Register alias address
  60:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  61:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */ 
  62:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* ------------- PWR registers bit address in the alias region ---------------*/
  63:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  64:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET            0x00U
  65:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET           0x04U
  66:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
  67:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)
  68:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  69:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  70:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  71:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    
  72:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CR_register_alias PWR CR Register alias address
  73:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  74:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */  
  75:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* --- CR Register ---*/
  76:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of LPSDSR bit */
  77:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define LPSDSR_BIT_NUMBER        PWR_CR_LPDS_Pos
  78:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_LPSDSR_BB             ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BI
  79:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  80:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of DBP bit */
  81:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define DBP_BIT_NUMBER            PWR_CR_DBP_Pos
  82:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_DBP_BB                ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_N
  83:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  84:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of PVDE bit */
  85:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define PVDE_BIT_NUMBER           PWR_CR_PVDE_Pos
  86:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CR_PVDE_BB               ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_
  87:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  88:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
  89:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
  90:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 3


  91:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  92:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
  93:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
  94:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
  95:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
  96:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* --- CSR Register ---*/
  97:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Alias word address of EWUP1 bit */
  98:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #define CSR_EWUP_BB(VAL)         ((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION
  99:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 100:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 101:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 102:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 103:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 104:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 105:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 106:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 107:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
 108:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 109:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Functions PWR Private Functions
 110:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  * brief   WFE cortex command overloaded for HAL_PWR_EnterSTOPMode usage only (see Workaround secti
 111:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  * @{
 112:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  */
 113:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void);
 114:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 115:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
 116:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** __NOINLINE
 117:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void)
 118:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
  26              		.loc 1 118 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 80B4     		push	{r7}
  32              		.cfi_def_cfa_offset 4
  33              		.cfi_offset 7, -4
  34 0002 00AF     		add	r7, sp, #0
  35              		.cfi_def_cfa_register 7
 119:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __asm volatile( "wfe" );
  36              		.loc 1 119 3
  37              		.syntax unified
  38              	@ 119 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
  39 0004 20BF     		wfe
  40              	@ 0 "" 2
 120:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __asm volatile( "nop" );
  41              		.loc 1 120 3
  42              	@ 120 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
  43 0006 00BF     		nop
  44              	@ 0 "" 2
 121:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
  45              		.loc 1 121 1
  46              		.thumb
  47              		.syntax unified
  48 0008 00BF     		nop
  49 000a BD46     		mov	sp, r7
  50              		.cfi_def_cfa_register 13
  51              		@ sp needed
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 4


  52 000c 80BC     		pop	{r7}
  53              		.cfi_restore 7
  54              		.cfi_def_cfa_offset 0
  55 000e 7047     		bx	lr
  56              		.cfi_endproc
  57              	.LFE65:
  59              		.section	.text.HAL_PWR_DeInit,"ax",%progbits
  60              		.align	1
  61              		.global	HAL_PWR_DeInit
  62              		.syntax unified
  63              		.thumb
  64              		.thumb_func
  66              	HAL_PWR_DeInit:
  67              	.LFB66:
 122:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 123:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 124:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 125:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 126:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 127:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 128:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
 129:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 130:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 131:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 132:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
 133:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *  @brief   Initialization and de-initialization functions
 134:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
 135:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @verbatim
 136:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 137:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
 138:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 139:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 140:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
 141:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       registers) is protected against possible unwanted
 142:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       write accesses.
 143:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 144:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 145:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
 146:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
 147:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 148:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @endverbatim
 149:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 150:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 151:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 152:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 153:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.  
 154:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 155:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 156:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
 157:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
  68              		.loc 1 157 1
  69              		.cfi_startproc
  70              		@ args = 0, pretend = 0, frame = 0
  71              		@ frame_needed = 1, uses_anonymous_args = 0
  72              		@ link register save eliminated.
  73 0000 80B4     		push	{r7}
  74              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 5


  75              		.cfi_offset 7, -4
  76 0002 00AF     		add	r7, sp, #0
  77              		.cfi_def_cfa_register 7
 158:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
  78              		.loc 1 158 3
  79 0004 074B     		ldr	r3, .L3
  80 0006 1B69     		ldr	r3, [r3, #16]
  81 0008 064A     		ldr	r2, .L3
  82 000a 43F08053 		orr	r3, r3, #268435456
  83 000e 1361     		str	r3, [r2, #16]
 159:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
  84              		.loc 1 159 3
  85 0010 044B     		ldr	r3, .L3
  86 0012 1B69     		ldr	r3, [r3, #16]
  87 0014 034A     		ldr	r2, .L3
  88 0016 23F08053 		bic	r3, r3, #268435456
  89 001a 1361     		str	r3, [r2, #16]
 160:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
  90              		.loc 1 160 1
  91 001c 00BF     		nop
  92 001e BD46     		mov	sp, r7
  93              		.cfi_def_cfa_register 13
  94              		@ sp needed
  95 0020 80BC     		pop	{r7}
  96              		.cfi_restore 7
  97              		.cfi_def_cfa_offset 0
  98 0022 7047     		bx	lr
  99              	.L4:
 100              		.align	2
 101              	.L3:
 102 0024 00100240 		.word	1073876992
 103              		.cfi_endproc
 104              	.LFE66:
 106              		.section	.text.HAL_PWR_EnableBkUpAccess,"ax",%progbits
 107              		.align	1
 108              		.global	HAL_PWR_EnableBkUpAccess
 109              		.syntax unified
 110              		.thumb
 111              		.thumb_func
 113              	HAL_PWR_EnableBkUpAccess:
 114              	.LFB67:
 161:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 162:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 163:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Enables access to the backup domain (RTC registers, RTC
 164:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         backup data registers ).
 165:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 166:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 167:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 168:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 169:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
 170:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 115              		.loc 1 170 1
 116              		.cfi_startproc
 117              		@ args = 0, pretend = 0, frame = 0
 118              		@ frame_needed = 1, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120 0000 80B4     		push	{r7}
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 6


 121              		.cfi_def_cfa_offset 4
 122              		.cfi_offset 7, -4
 123 0002 00AF     		add	r7, sp, #0
 124              		.cfi_def_cfa_register 7
 171:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable access to RTC and backup registers */
 172:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
 125              		.loc 1 172 3
 126 0004 034B     		ldr	r3, .L6
 127              		.loc 1 172 32
 128 0006 0122     		movs	r2, #1
 129 0008 1A60     		str	r2, [r3]
 173:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 130              		.loc 1 173 1
 131 000a 00BF     		nop
 132 000c BD46     		mov	sp, r7
 133              		.cfi_def_cfa_register 13
 134              		@ sp needed
 135 000e 80BC     		pop	{r7}
 136              		.cfi_restore 7
 137              		.cfi_def_cfa_offset 0
 138 0010 7047     		bx	lr
 139              	.L7:
 140 0012 00BF     		.align	2
 141              	.L6:
 142 0014 20000E42 		.word	1108213792
 143              		.cfi_endproc
 144              	.LFE67:
 146              		.section	.text.HAL_PWR_DisableBkUpAccess,"ax",%progbits
 147              		.align	1
 148              		.global	HAL_PWR_DisableBkUpAccess
 149              		.syntax unified
 150              		.thumb
 151              		.thumb_func
 153              	HAL_PWR_DisableBkUpAccess:
 154              	.LFB68:
 174:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 175:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 176:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Disables access to the backup domain (RTC registers, RTC
 177:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         backup data registers).
 178:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 179:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 180:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 181:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 182:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 183:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 155              		.loc 1 183 1
 156              		.cfi_startproc
 157              		@ args = 0, pretend = 0, frame = 0
 158              		@ frame_needed = 1, uses_anonymous_args = 0
 159              		@ link register save eliminated.
 160 0000 80B4     		push	{r7}
 161              		.cfi_def_cfa_offset 4
 162              		.cfi_offset 7, -4
 163 0002 00AF     		add	r7, sp, #0
 164              		.cfi_def_cfa_register 7
 184:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable access to RTC and backup registers */
 185:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 7


 165              		.loc 1 185 3
 166 0004 034B     		ldr	r3, .L9
 167              		.loc 1 185 32
 168 0006 0022     		movs	r2, #0
 169 0008 1A60     		str	r2, [r3]
 186:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 170              		.loc 1 186 1
 171 000a 00BF     		nop
 172 000c BD46     		mov	sp, r7
 173              		.cfi_def_cfa_register 13
 174              		@ sp needed
 175 000e 80BC     		pop	{r7}
 176              		.cfi_restore 7
 177              		.cfi_def_cfa_offset 0
 178 0010 7047     		bx	lr
 179              	.L10:
 180 0012 00BF     		.align	2
 181              	.L9:
 182 0014 20000E42 		.word	1108213792
 183              		.cfi_endproc
 184              	.LFE68:
 186              		.section	.text.HAL_PWR_ConfigPVD,"ax",%progbits
 187              		.align	1
 188              		.global	HAL_PWR_ConfigPVD
 189              		.syntax unified
 190              		.thumb
 191              		.thumb_func
 193              	HAL_PWR_ConfigPVD:
 194              	.LFB69:
 187:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 188:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 189:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @}
 190:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 191:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 192:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
 193:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief    Low Power modes configuration functions
 194:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *
 195:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @verbatim
 196:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 197:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 198:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 199:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      
 200:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** PVD configuration ***
 201:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     =========================
 202:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 203:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 204:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 205:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 206:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower
 207:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 208:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           line16 and can generate an interrupt if enabled. This is done through
 209:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           __HAL_PVD_EXTI_ENABLE_IT() macro.
 210:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
 211:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 212:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 213:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     ================================
 214:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 8


 215:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) WakeUp pin is used to wake up the system from Standby mode. This pin is
 216:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           forced in input pull-down configuration and is active on rising edges.
 217:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) There is one WakeUp pin:
 218:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           WakeUp Pin 1 on PA.00.
 219:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 220:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 221:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 222:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     *** Low Power modes configuration ***
 223:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     =====================================
 224:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      [..]
 225:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The device features 3 low-power modes:
 226:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Sleep mode: CPU clock off, all peripherals including Cortex-M3 core peripherals like 
 227:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                       NVIC, SysTick, etc. are kept running
 228:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Stop mode: All clocks are stopped
 229:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Standby mode: 1.8V domain powered off
 230:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 231:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 232:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Sleep mode ***
 233:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    ==================
 234:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 235:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 236:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_S
 237:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****               functions with
 238:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 239:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 240:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      
 241:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 242:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WFI entry mode, Any peripheral interrupt acknowledged by the nested vectored interrupt
 243:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 244:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WFE entry mode, Any wakeup event can wake up the device from Sleep mode.
 245:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (+++) Any peripheral interrupt w/o NVIC configuration & SEVONPEND bit set in the Cortex 
 246:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (+++) Any EXTI Line (Internal or External) configured in Event mode
 247:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 248:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Stop mode ***
 249:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    =================
 250:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     [..]
 251:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The Stop mode is based on the Cortex-M3 deepsleep mode combined with peripheral
 252:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       clock gating. The voltage regulator can be configured either in normal or low-power mode.
 253:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       In Stop mode, all clocks in the 1.8 V domain are stopped, the PLL, the HSI and the HSE RC 
 254:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       oscillators are disabled. SRAM and register contents are preserved.
 255:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       In Stop mode, all I/O pins keep the same state as in Run mode.
 256:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 257:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 258:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_REGULATOR_VALUE, PWR_SLEEPE
 259:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              function with:
 260:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_MAINREGULATOR_ON: Main regulator ON.
 261:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.
 262:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
 263:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
 264:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 265:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) WFI entry mode, Any EXTI Line (Internal or External) configured in Interrupt mode wi
 266:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (++) WFE entry mode, Any EXTI Line (Internal or External) configured in Event mode.
 267:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 268:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Standby mode ***
 269:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    ====================
 270:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****      [..]
 271:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based on the
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 9


 272:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       Cortex-M3 deepsleep mode, with the voltage regulator disabled. The 1.8 V domain is 
 273:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       consequently powered off. The PLL, the HSI oscillator and the HSE oscillator are also 
 274:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       switched off. SRAM and register contents are lost except for registers in the Backup domain 
 275:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       and Standby circuitry
 276:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       
 277:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 278:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 279:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 280:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         (++) WKUP pin rising edge, RTC alarm event rising edge, external Reset in 
 281:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****              NRSTpin, IWDG Reset
 282:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 283:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 284:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        =============================================
 285:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        [..]
 286:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         
 287:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (+) The MCU can be woken up from low-power mode by an RTC Alarm event, 
 288:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            without depending on an external interrupt (Auto-wakeup mode).
 289:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    
 290:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
 291:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 292:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****            (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
 293:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****                 configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() functio
 294:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 295:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    *** PWR Workarounds linked to Silicon Limitation ***
 296:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        ====================================================
 297:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        [..]
 298:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        Below the list of all silicon limitations known on STM32F1xx prouct.
 299:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 300:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****        (#)Workarounds Implemented inside PWR HAL Driver
 301:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****           (##)Debugging Stop mode with WFE entry - overloaded the WFE by an internal function    
 302:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****         
 303:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** @endverbatim
 304:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @{
 305:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 306:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 307:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 308:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 309:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param  sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
 310:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         information for the PVD.
 311:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 312:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         more details about the voltage threshold corresponding to each
 313:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         detection level.
 314:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 315:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 316:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 317:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 195              		.loc 1 317 1
 196              		.cfi_startproc
 197              		@ args = 0, pretend = 0, frame = 8
 198              		@ frame_needed = 1, uses_anonymous_args = 0
 199              		@ link register save eliminated.
 200 0000 80B4     		push	{r7}
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 7, -4
 203 0002 83B0     		sub	sp, sp, #12
 204              		.cfi_def_cfa_offset 16
 205 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 10


 206              		.cfi_def_cfa_register 7
 207 0006 7860     		str	r0, [r7, #4]
 318:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 319:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 320:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 321:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 322:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set PLS[7:5] bits according to PVDLevel value */
 323:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
 208              		.loc 1 323 3
 209 0008 2A4B     		ldr	r3, .L17
 210 000a 1B68     		ldr	r3, [r3]
 211 000c 23F0E002 		bic	r2, r3, #224
 212 0010 7B68     		ldr	r3, [r7, #4]
 213 0012 1B68     		ldr	r3, [r3]
 214 0014 2749     		ldr	r1, .L17
 215 0016 1343     		orrs	r3, r3, r2
 216 0018 0B60     		str	r3, [r1]
 324:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 325:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear any previous config. Keep it clear if no event or IT mode is selected */
 326:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 217              		.loc 1 326 3
 218 001a 274B     		ldr	r3, .L17+4
 219 001c 5B68     		ldr	r3, [r3, #4]
 220 001e 264A     		ldr	r2, .L17+4
 221 0020 23F48033 		bic	r3, r3, #65536
 222 0024 5360     		str	r3, [r2, #4]
 327:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 223              		.loc 1 327 3
 224 0026 244B     		ldr	r3, .L17+4
 225 0028 1B68     		ldr	r3, [r3]
 226 002a 234A     		ldr	r2, .L17+4
 227 002c 23F48033 		bic	r3, r3, #65536
 228 0030 1360     		str	r3, [r2]
 328:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 229              		.loc 1 328 3
 230 0032 214B     		ldr	r3, .L17+4
 231 0034 DB68     		ldr	r3, [r3, #12]
 232 0036 204A     		ldr	r2, .L17+4
 233 0038 23F48033 		bic	r3, r3, #65536
 234 003c D360     		str	r3, [r2, #12]
 329:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 235              		.loc 1 329 3
 236 003e 1E4B     		ldr	r3, .L17+4
 237 0040 9B68     		ldr	r3, [r3, #8]
 238 0042 1D4A     		ldr	r2, .L17+4
 239 0044 23F48033 		bic	r3, r3, #65536
 240 0048 9360     		str	r3, [r2, #8]
 330:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 331:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure interrupt mode */
 332:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 241              		.loc 1 332 17
 242 004a 7B68     		ldr	r3, [r7, #4]
 243 004c 5B68     		ldr	r3, [r3, #4]
 244              		.loc 1 332 24
 245 004e 03F48033 		and	r3, r3, #65536
 246              		.loc 1 332 5
 247 0052 002B     		cmp	r3, #0
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 11


 248 0054 05D0     		beq	.L12
 333:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 334:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 249              		.loc 1 334 5
 250 0056 184B     		ldr	r3, .L17+4
 251 0058 1B68     		ldr	r3, [r3]
 252 005a 174A     		ldr	r2, .L17+4
 253 005c 43F48033 		orr	r3, r3, #65536
 254 0060 1360     		str	r3, [r2]
 255              	.L12:
 335:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 336:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 337:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure event mode */
 338:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 256              		.loc 1 338 17
 257 0062 7B68     		ldr	r3, [r7, #4]
 258 0064 5B68     		ldr	r3, [r3, #4]
 259              		.loc 1 338 24
 260 0066 03F40033 		and	r3, r3, #131072
 261              		.loc 1 338 5
 262 006a 002B     		cmp	r3, #0
 263 006c 05D0     		beq	.L13
 339:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 340:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
 264              		.loc 1 340 5
 265 006e 124B     		ldr	r3, .L17+4
 266 0070 5B68     		ldr	r3, [r3, #4]
 267 0072 114A     		ldr	r2, .L17+4
 268 0074 43F48033 		orr	r3, r3, #65536
 269 0078 5360     		str	r3, [r2, #4]
 270              	.L13:
 341:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 342:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 343:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Configure the edge */
 344:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 271              		.loc 1 344 17
 272 007a 7B68     		ldr	r3, [r7, #4]
 273 007c 5B68     		ldr	r3, [r3, #4]
 274              		.loc 1 344 24
 275 007e 03F00103 		and	r3, r3, #1
 276              		.loc 1 344 5
 277 0082 002B     		cmp	r3, #0
 278 0084 05D0     		beq	.L14
 345:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 346:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 279              		.loc 1 346 5
 280 0086 0C4B     		ldr	r3, .L17+4
 281 0088 9B68     		ldr	r3, [r3, #8]
 282 008a 0B4A     		ldr	r2, .L17+4
 283 008c 43F48033 		orr	r3, r3, #65536
 284 0090 9360     		str	r3, [r2, #8]
 285              	.L14:
 347:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 348:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   
 349:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 286              		.loc 1 349 17
 287 0092 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 12


 288 0094 5B68     		ldr	r3, [r3, #4]
 289              		.loc 1 349 24
 290 0096 03F00203 		and	r3, r3, #2
 291              		.loc 1 349 5
 292 009a 002B     		cmp	r3, #0
 293 009c 05D0     		beq	.L16
 350:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 351:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 294              		.loc 1 351 5
 295 009e 064B     		ldr	r3, .L17+4
 296 00a0 DB68     		ldr	r3, [r3, #12]
 297 00a2 054A     		ldr	r2, .L17+4
 298 00a4 43F48033 		orr	r3, r3, #65536
 299 00a8 D360     		str	r3, [r2, #12]
 300              	.L16:
 352:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 353:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 301              		.loc 1 353 1
 302 00aa 00BF     		nop
 303 00ac 0C37     		adds	r7, r7, #12
 304              		.cfi_def_cfa_offset 4
 305 00ae BD46     		mov	sp, r7
 306              		.cfi_def_cfa_register 13
 307              		@ sp needed
 308 00b0 80BC     		pop	{r7}
 309              		.cfi_restore 7
 310              		.cfi_def_cfa_offset 0
 311 00b2 7047     		bx	lr
 312              	.L18:
 313              		.align	2
 314              	.L17:
 315 00b4 00700040 		.word	1073770496
 316 00b8 00040140 		.word	1073808384
 317              		.cfi_endproc
 318              	.LFE69:
 320              		.section	.text.HAL_PWR_EnablePVD,"ax",%progbits
 321              		.align	1
 322              		.global	HAL_PWR_EnablePVD
 323              		.syntax unified
 324              		.thumb
 325              		.thumb_func
 327              	HAL_PWR_EnablePVD:
 328              	.LFB70:
 354:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 355:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 356:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Enables the Power Voltage Detector(PVD).
 357:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 358:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 359:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
 360:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 329              		.loc 1 360 1
 330              		.cfi_startproc
 331              		@ args = 0, pretend = 0, frame = 0
 332              		@ frame_needed = 1, uses_anonymous_args = 0
 333              		@ link register save eliminated.
 334 0000 80B4     		push	{r7}
 335              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 13


 336              		.cfi_offset 7, -4
 337 0002 00AF     		add	r7, sp, #0
 338              		.cfi_def_cfa_register 7
 361:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable the power voltage detector */
 362:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
 339              		.loc 1 362 3
 340 0004 034B     		ldr	r3, .L20
 341              		.loc 1 362 33
 342 0006 0122     		movs	r2, #1
 343 0008 1A60     		str	r2, [r3]
 363:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 344              		.loc 1 363 1
 345 000a 00BF     		nop
 346 000c BD46     		mov	sp, r7
 347              		.cfi_def_cfa_register 13
 348              		@ sp needed
 349 000e 80BC     		pop	{r7}
 350              		.cfi_restore 7
 351              		.cfi_def_cfa_offset 0
 352 0010 7047     		bx	lr
 353              	.L21:
 354 0012 00BF     		.align	2
 355              	.L20:
 356 0014 10000E42 		.word	1108213776
 357              		.cfi_endproc
 358              	.LFE70:
 360              		.section	.text.HAL_PWR_DisablePVD,"ax",%progbits
 361              		.align	1
 362              		.global	HAL_PWR_DisablePVD
 363              		.syntax unified
 364              		.thumb
 365              		.thumb_func
 367              	HAL_PWR_DisablePVD:
 368              	.LFB71:
 364:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 365:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 366:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  Disables the Power Voltage Detector(PVD).
 367:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 368:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 369:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 370:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 369              		.loc 1 370 1
 370              		.cfi_startproc
 371              		@ args = 0, pretend = 0, frame = 0
 372              		@ frame_needed = 1, uses_anonymous_args = 0
 373              		@ link register save eliminated.
 374 0000 80B4     		push	{r7}
 375              		.cfi_def_cfa_offset 4
 376              		.cfi_offset 7, -4
 377 0002 00AF     		add	r7, sp, #0
 378              		.cfi_def_cfa_register 7
 371:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable the power voltage detector */
 372:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
 379              		.loc 1 372 3
 380 0004 034B     		ldr	r3, .L23
 381              		.loc 1 372 33
 382 0006 0022     		movs	r2, #0
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 14


 383 0008 1A60     		str	r2, [r3]
 373:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 384              		.loc 1 373 1
 385 000a 00BF     		nop
 386 000c BD46     		mov	sp, r7
 387              		.cfi_def_cfa_register 13
 388              		@ sp needed
 389 000e 80BC     		pop	{r7}
 390              		.cfi_restore 7
 391              		.cfi_def_cfa_offset 0
 392 0010 7047     		bx	lr
 393              	.L24:
 394 0012 00BF     		.align	2
 395              	.L23:
 396 0014 10000E42 		.word	1108213776
 397              		.cfi_endproc
 398              	.LFE71:
 400              		.section	.text.HAL_PWR_EnableWakeUpPin,"ax",%progbits
 401              		.align	1
 402              		.global	HAL_PWR_EnableWakeUpPin
 403              		.syntax unified
 404              		.thumb
 405              		.thumb_func
 407              	HAL_PWR_EnableWakeUpPin:
 408              	.LFB72:
 374:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 375:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 376:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enables the WakeUp PINx functionality.
 377:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to enable.
 378:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 379:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 380:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 381:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 382:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
 383:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 409              		.loc 1 383 1
 410              		.cfi_startproc
 411              		@ args = 0, pretend = 0, frame = 16
 412              		@ frame_needed = 1, uses_anonymous_args = 0
 413              		@ link register save eliminated.
 414 0000 80B4     		push	{r7}
 415              		.cfi_def_cfa_offset 4
 416              		.cfi_offset 7, -4
 417 0002 85B0     		sub	sp, sp, #20
 418              		.cfi_def_cfa_offset 24
 419 0004 00AF     		add	r7, sp, #0
 420              		.cfi_def_cfa_register 7
 421 0006 7860     		str	r0, [r7, #4]
 422 0008 7B68     		ldr	r3, [r7, #4]
 423 000a FB60     		str	r3, [r7, #12]
 424              	.LBB6:
 425              	.LBB7:
 426              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.0.4
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 15


   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     09. April 2018
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 16


  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 117:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 17


 119:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 122:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 129:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 131:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 133:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 144:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 145:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 158:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 159:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 160:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 168:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 18


 176:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 187:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 202:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 207:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 211:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 212:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 216:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 218:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 221:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 222:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 225:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 228:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 229:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               xPSR Register value
 232:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 19


 233:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 236:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 239:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 243:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 247:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 249:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 250:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 253:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 266:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 269:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 270:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 271:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 272:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 279:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 281:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 282:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 283:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 285:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 289:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 20


 290:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 291:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 295:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 296:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 300:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 301:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 303:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 310:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 315:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 318:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 319:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 322:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 323:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 325:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 327:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 331:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 345:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 21


 347:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 352:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               SP Register value
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 358:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 359:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 366:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 370:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 375:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 378:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 382:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 384:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 385:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 386:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 390:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 391:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 399:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 403:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 22


 404:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 406:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 408:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 412:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 418:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 420:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 424:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 429:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 430:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 431:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 435:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 436:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 439:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 441:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 443:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 444:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 445:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 446:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 447:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 450:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 452:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 454:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 455:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 456:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 457:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 458:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 460:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 23


 461:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 463:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 464:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 465:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 467:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 472:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 475:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 476:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 479:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 482:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 484:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 486:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 487:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 488:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 491:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 493:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 495:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 496:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 499:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 503:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 505:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 507:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 508:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 509:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 510:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 511:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 516:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 24


 518:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 520:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 521:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 522:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 523:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 526:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 530:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 533:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 538:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 541:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 542:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 544:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 545:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 546:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 548:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 549:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 550:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 552:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 553:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 557:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 559:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 561:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 562:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 563:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 565:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 569:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 571:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 573:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 574:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 25


 575:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 579:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 580:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 583:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 584:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 588:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 589:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 592:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 594:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:Drivers/CMSIS/Include/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 598:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 599:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 600:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 601:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 602:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 603:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 604:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 605:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 607:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 611:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 614:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 616:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 619:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 620:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 621:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 623:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 624:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 625:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 626:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 627:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 628:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 629:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 26


 632:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 633:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 634:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 637:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 639:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 644:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 646:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 647:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 648:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 649:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 651:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 655:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 658:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 660:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 664:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 666:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 667:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 668:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 669:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 670:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 671:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 675:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 676:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 685:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 686:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 687:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 27


 689:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 690:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 691:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 692:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 693:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 695:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 699:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 702:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 704:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:Drivers/CMSIS/Include/cmsis_gcc.h ****   return 0U;
 707:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 708:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 709:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 711:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 712:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 713:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 714:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 715:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 716:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 717:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:Drivers/CMSIS/Include/cmsis_gcc.h ****   mode.
 721:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 722:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 725:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 727:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:Drivers/CMSIS/Include/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 732:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 734:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 735:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 736:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 737:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 739:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:Drivers/CMSIS/Include/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:Drivers/CMSIS/Include/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 743:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 28


 746:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 748:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:Drivers/CMSIS/Include/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 752:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 754:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 755:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 756:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 757:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 760:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 761:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 762:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 763:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 766:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 768:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 772:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 776:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 777:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 778:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 780:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 781:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 782:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(0U);
 783:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 784:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 785:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 787:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 788:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 789:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:Drivers/CMSIS/Include/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:Drivers/CMSIS/Include/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:Drivers/CMSIS/Include/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:Drivers/CMSIS/Include/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 802:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 29


 803:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 804:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 805:Drivers/CMSIS/Include/cmsis_gcc.h ****   (void)fpscr;
 806:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 807:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 808:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 809:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 810:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 816:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 817:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 818:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 819:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 827:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 829:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 831:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 832:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 833:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 834:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 836:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 838:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 839:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 842:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 844:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 845:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 846:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 847:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 850:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 853:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 854:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 855:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 857:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 859:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 30


 860:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 861:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 865:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 866:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 868:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 870:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 871:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 872:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 873:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 877:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 879:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 881:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 882:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 883:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 884:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 886:Drivers/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 888:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 890:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 892:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 893:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 894:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 895:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 899:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 900:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 902:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 905:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 906:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 907:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 909:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 910:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 911:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 912:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 913:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 914:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 31


 917:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 918:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 919:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 921:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 922:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 923:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 925:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 926:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 927:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 928:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 929:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 933:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 934:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 936:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 939:Drivers/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 940:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 941:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 943:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 944:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 945:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 946:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 947:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 948:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 953:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 954:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 956:Drivers/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 957:Drivers/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 958:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 959:Drivers/CMSIS/Include/cmsis_gcc.h ****     return op1;
 960:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 961:Drivers/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 963:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 964:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 965:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 966:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 967:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:Drivers/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:Drivers/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 972:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 32


 974:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 975:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 976:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 980:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 981:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 983:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 984:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 985:Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 427              		.loc 2 988 4
 428 000c FB68     		ldr	r3, [r7, #12]
 429              		.syntax unified
 430              	@ 988 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 431 000e 93FAA3F3 		rbit r3, r3
 432              	@ 0 "" 2
 433              		.thumb
 434              		.syntax unified
 435 0012 BB60     		str	r3, [r7, #8]
 989:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 990:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
 991:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 992:Drivers/CMSIS/Include/cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
 993:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
 994:Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 995:Drivers/CMSIS/Include/cmsis_gcc.h ****     result <<= 1U;
 996:Drivers/CMSIS/Include/cmsis_gcc.h ****     result |= value & 1U;
 997:Drivers/CMSIS/Include/cmsis_gcc.h ****     s--;
 998:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 999:Drivers/CMSIS/Include/cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
1000:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
1001:Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 436              		.loc 2 1001 10
 437 0014 BB68     		ldr	r3, [r7, #8]
 438              	.LBE7:
 439              	.LBE6:
 384:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
 385:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 386:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Enable the EWUPx pin */
 387:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
 440              		.loc 1 387 22
 441 0016 B3FA83F3 		clz	r3, r3
 442 001a DBB2     		uxtb	r3, r3
 443 001c 1A46     		mov	r2, r3
 444 001e 054B     		ldr	r3, .L27
 445 0020 1344     		add	r3, r3, r2
 446 0022 9B00     		lsls	r3, r3, #2
 447              		.loc 1 387 4
 448 0024 1A46     		mov	r2, r3
 449              		.loc 1 387 46
 450 0026 0123     		movs	r3, #1
 451 0028 1360     		str	r3, [r2]
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 33


 388:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 452              		.loc 1 388 1
 453 002a 00BF     		nop
 454 002c 1437     		adds	r7, r7, #20
 455              		.cfi_def_cfa_offset 4
 456 002e BD46     		mov	sp, r7
 457              		.cfi_def_cfa_register 13
 458              		@ sp needed
 459 0030 80BC     		pop	{r7}
 460              		.cfi_restore 7
 461              		.cfi_def_cfa_offset 0
 462 0032 7047     		bx	lr
 463              	.L28:
 464              		.align	2
 465              	.L27:
 466 0034 20808310 		.word	277053472
 467              		.cfi_endproc
 468              	.LFE72:
 470              		.section	.text.HAL_PWR_DisableWakeUpPin,"ax",%progbits
 471              		.align	1
 472              		.global	HAL_PWR_DisableWakeUpPin
 473              		.syntax unified
 474              		.thumb
 475              		.thumb_func
 477              	HAL_PWR_DisableWakeUpPin:
 478              	.LFB73:
 389:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 390:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 391:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables the WakeUp PINx functionality.
 392:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
 393:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 394:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 395:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 396:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 397:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 398:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 479              		.loc 1 398 1
 480              		.cfi_startproc
 481              		@ args = 0, pretend = 0, frame = 16
 482              		@ frame_needed = 1, uses_anonymous_args = 0
 483              		@ link register save eliminated.
 484 0000 80B4     		push	{r7}
 485              		.cfi_def_cfa_offset 4
 486              		.cfi_offset 7, -4
 487 0002 85B0     		sub	sp, sp, #20
 488              		.cfi_def_cfa_offset 24
 489 0004 00AF     		add	r7, sp, #0
 490              		.cfi_def_cfa_register 7
 491 0006 7860     		str	r0, [r7, #4]
 492 0008 7B68     		ldr	r3, [r7, #4]
 493 000a FB60     		str	r3, [r7, #12]
 494              	.LBB8:
 495              	.LBB9:
 988:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 496              		.loc 2 988 4
 497 000c FB68     		ldr	r3, [r7, #12]
 498              		.syntax unified
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 34


 499              	@ 988 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 500 000e 93FAA3F3 		rbit r3, r3
 501              	@ 0 "" 2
 502              		.thumb
 503              		.syntax unified
 504 0012 BB60     		str	r3, [r7, #8]
 505              		.loc 2 1001 10
 506 0014 BB68     		ldr	r3, [r7, #8]
 507              	.LBE9:
 508              	.LBE8:
 399:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
 400:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 401:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Disable the EWUPx pin */
 402:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
 509              		.loc 1 402 22
 510 0016 B3FA83F3 		clz	r3, r3
 511 001a DBB2     		uxtb	r3, r3
 512 001c 1A46     		mov	r2, r3
 513 001e 054B     		ldr	r3, .L31
 514 0020 1344     		add	r3, r3, r2
 515 0022 9B00     		lsls	r3, r3, #2
 516              		.loc 1 402 4
 517 0024 1A46     		mov	r2, r3
 518              		.loc 1 402 46
 519 0026 0023     		movs	r3, #0
 520 0028 1360     		str	r3, [r2]
 403:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 521              		.loc 1 403 1
 522 002a 00BF     		nop
 523 002c 1437     		adds	r7, r7, #20
 524              		.cfi_def_cfa_offset 4
 525 002e BD46     		mov	sp, r7
 526              		.cfi_def_cfa_register 13
 527              		@ sp needed
 528 0030 80BC     		pop	{r7}
 529              		.cfi_restore 7
 530              		.cfi_def_cfa_offset 0
 531 0032 7047     		bx	lr
 532              	.L32:
 533              		.align	2
 534              	.L31:
 535 0034 20808310 		.word	277053472
 536              		.cfi_endproc
 537              	.LFE73:
 539              		.section	.text.HAL_PWR_EnterSLEEPMode,"ax",%progbits
 540              		.align	1
 541              		.global	HAL_PWR_EnterSLEEPMode
 542              		.syntax unified
 543              		.thumb
 544              		.thumb_func
 546              	HAL_PWR_EnterSLEEPMode:
 547              	.LFB74:
 404:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 405:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 406:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Sleep mode.
 407:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
 408:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Regulator state as no effect in SLEEP mode -  allows to support portability f
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 35


 409:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction.
 410:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
 411:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           the interrupt wake up source.
 412:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *           This parameter can be one of the following values:
 413:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 414:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 415:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 416:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 417:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 418:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 548              		.loc 1 418 1
 549              		.cfi_startproc
 550              		@ args = 0, pretend = 0, frame = 8
 551              		@ frame_needed = 1, uses_anonymous_args = 0
 552              		@ link register save eliminated.
 553 0000 80B4     		push	{r7}
 554              		.cfi_def_cfa_offset 4
 555              		.cfi_offset 7, -4
 556 0002 83B0     		sub	sp, sp, #12
 557              		.cfi_def_cfa_offset 16
 558 0004 00AF     		add	r7, sp, #0
 559              		.cfi_def_cfa_register 7
 560 0006 7860     		str	r0, [r7, #4]
 561 0008 0B46     		mov	r3, r1
 562 000a FB70     		strb	r3, [r7, #3]
 419:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 420:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* No check on Regulator because parameter not used in SLEEP mode */
 421:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Prevent unused argument(s) compilation warning */
 422:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   UNUSED(Regulator);
 423:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 424:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 425:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 426:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
 427:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 563              		.loc 1 427 3
 564 000c 094B     		ldr	r3, .L37
 565 000e 1B69     		ldr	r3, [r3, #16]
 566 0010 084A     		ldr	r2, .L37
 567 0012 23F00403 		bic	r3, r3, #4
 568 0016 1361     		str	r3, [r2, #16]
 428:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 429:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 430:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 569              		.loc 1 430 5
 570 0018 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 571 001a 012B     		cmp	r3, #1
 572 001c 01D1     		bne	.L34
 431:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 432:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 433:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFI();
 573              		.loc 1 433 5
 574              		.syntax unified
 575              	@ 433 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 576 001e 30BF     		wfi
 577              	@ 0 "" 2
 434:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 435:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   else
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 36


 436:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 437:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 438:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __SEV();
 439:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 440:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 441:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 442:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 578              		.loc 1 442 1
 579              		.thumb
 580              		.syntax unified
 581 0020 02E0     		b	.L36
 582              	.L34:
 438:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 583              		.loc 1 438 5
 584              		.syntax unified
 585              	@ 438 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 586 0022 40BF     		sev
 587              	@ 0 "" 2
 439:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFE();
 588              		.loc 1 439 5
 589              	@ 439 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 590 0024 20BF     		wfe
 591              	@ 0 "" 2
 440:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 592              		.loc 1 440 5
 593              	@ 440 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 594 0026 20BF     		wfe
 595              	@ 0 "" 2
 596              		.thumb
 597              		.syntax unified
 598              	.L36:
 599              		.loc 1 442 1
 600 0028 00BF     		nop
 601 002a 0C37     		adds	r7, r7, #12
 602              		.cfi_def_cfa_offset 4
 603 002c BD46     		mov	sp, r7
 604              		.cfi_def_cfa_register 13
 605              		@ sp needed
 606 002e 80BC     		pop	{r7}
 607              		.cfi_restore 7
 608              		.cfi_def_cfa_offset 0
 609 0030 7047     		bx	lr
 610              	.L38:
 611 0032 00BF     		.align	2
 612              	.L37:
 613 0034 00ED00E0 		.word	-536810240
 614              		.cfi_endproc
 615              	.LFE74:
 617              		.section	.text.HAL_PWR_EnterSTOPMode,"ax",%progbits
 618              		.align	1
 619              		.global	HAL_PWR_EnterSTOPMode
 620              		.syntax unified
 621              		.thumb
 622              		.thumb_func
 624              	HAL_PWR_EnterSTOPMode:
 625              	.LFB75:
 443:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 37


 444:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 445:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Stop mode. 
 446:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
 447:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  When exiting Stop mode by using an interrupt or a wakeup event,
 448:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *        HSI RC oscillator is selected as system clock.
 449:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  When the voltage regulator operates in low power mode, an additional
 450:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 451:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 452:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *         is higher although the startup time is reduced.    
 453:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Specifies the regulator state in Stop mode.
 454:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 455:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
 456:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
 457:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
 458:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 459:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
 460:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction   
 461:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 462:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 463:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 464:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 626              		.loc 1 464 1
 627              		.cfi_startproc
 628              		@ args = 0, pretend = 0, frame = 8
 629              		@ frame_needed = 1, uses_anonymous_args = 0
 630 0000 80B5     		push	{r7, lr}
 631              		.cfi_def_cfa_offset 8
 632              		.cfi_offset 7, -8
 633              		.cfi_offset 14, -4
 634 0002 82B0     		sub	sp, sp, #8
 635              		.cfi_def_cfa_offset 16
 636 0004 00AF     		add	r7, sp, #0
 637              		.cfi_def_cfa_register 7
 638 0006 7860     		str	r0, [r7, #4]
 639 0008 0B46     		mov	r3, r1
 640 000a FB70     		strb	r3, [r7, #3]
 465:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 466:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 467:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 468:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 469:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */
 470:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
 641              		.loc 1 470 3
 642 000c 134B     		ldr	r3, .L42
 643 000e 1B68     		ldr	r3, [r3]
 644 0010 124A     		ldr	r2, .L42
 645 0012 23F00203 		bic	r3, r3, #2
 646 0016 1360     		str	r3, [r2]
 471:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 472:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator p
 473:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
 647              		.loc 1 473 3
 648 0018 104B     		ldr	r3, .L42
 649 001a 1B68     		ldr	r3, [r3]
 650 001c 23F00102 		bic	r2, r3, #1
 651 0020 0E49     		ldr	r1, .L42
 652 0022 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 38


 653 0024 1343     		orrs	r3, r3, r2
 654 0026 0B60     		str	r3, [r1]
 474:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 475:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 476:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 655              		.loc 1 476 3
 656 0028 0D4B     		ldr	r3, .L42+4
 657 002a 1B69     		ldr	r3, [r3, #16]
 658 002c 0C4A     		ldr	r2, .L42+4
 659 002e 43F00403 		orr	r3, r3, #4
 660 0032 1361     		str	r3, [r2, #16]
 477:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 478:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select Stop mode entry --------------------------------------------------*/
 479:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 661              		.loc 1 479 5
 662 0034 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 663 0036 012B     		cmp	r3, #1
 664 0038 01D1     		bne	.L40
 480:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 481:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 482:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __WFI();
 665              		.loc 1 482 5
 666              		.syntax unified
 667              	@ 482 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 668 003a 30BF     		wfi
 669              	@ 0 "" 2
 670              		.thumb
 671              		.syntax unified
 672 003c 04E0     		b	.L41
 673              	.L40:
 483:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 484:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   else
 485:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
 486:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 487:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __SEV();
 674              		.loc 1 487 5
 675              		.syntax unified
 676              	@ 487 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 677 003e 40BF     		sev
 678              	@ 0 "" 2
 488:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 679              		.loc 1 488 5
 680              		.thumb
 681              		.syntax unified
 682 0040 FFF7FEFF 		bl	PWR_OverloadWfe
 489:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 683              		.loc 1 489 5
 684 0044 FFF7FEFF 		bl	PWR_OverloadWfe
 685              	.L41:
 490:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 491:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 492:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 686              		.loc 1 492 3
 687 0048 054B     		ldr	r3, .L42+4
 688 004a 1B69     		ldr	r3, [r3, #16]
 689 004c 044A     		ldr	r2, .L42+4
 690 004e 23F00403 		bic	r3, r3, #4
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 39


 691 0052 1361     		str	r3, [r2, #16]
 493:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 692              		.loc 1 493 1
 693 0054 00BF     		nop
 694 0056 0837     		adds	r7, r7, #8
 695              		.cfi_def_cfa_offset 8
 696 0058 BD46     		mov	sp, r7
 697              		.cfi_def_cfa_register 13
 698              		@ sp needed
 699 005a 80BD     		pop	{r7, pc}
 700              	.L43:
 701              		.align	2
 702              	.L42:
 703 005c 00700040 		.word	1073770496
 704 0060 00ED00E0 		.word	-536810240
 705              		.cfi_endproc
 706              	.LFE75:
 708              		.section	.text.HAL_PWR_EnterSTANDBYMode,"ax",%progbits
 709              		.align	1
 710              		.global	HAL_PWR_EnterSTANDBYMode
 711              		.syntax unified
 712              		.thumb
 713              		.thumb_func
 715              	HAL_PWR_EnterSTANDBYMode:
 716              	.LFB76:
 494:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 495:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 496:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enters Standby mode.
 497:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note  In Standby mode, all I/O pins are high impedance except for:
 498:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - Reset pad (still available) 
 499:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - TAMPER pin if configured for tamper or calibration out.
 500:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *          - WKUP pin (PA0) if enabled.
 501:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 502:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 503:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 504:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 717              		.loc 1 504 1
 718              		.cfi_startproc
 719              		@ args = 0, pretend = 0, frame = 0
 720              		@ frame_needed = 1, uses_anonymous_args = 0
 721              		@ link register save eliminated.
 722 0000 80B4     		push	{r7}
 723              		.cfi_def_cfa_offset 4
 724              		.cfi_offset 7, -4
 725 0002 00AF     		add	r7, sp, #0
 726              		.cfi_def_cfa_register 7
 505:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Select Standby mode */
 506:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(PWR->CR, PWR_CR_PDDS);
 727              		.loc 1 506 3
 728 0004 084B     		ldr	r3, .L45
 729 0006 1B68     		ldr	r3, [r3]
 730 0008 074A     		ldr	r2, .L45
 731 000a 43F00203 		orr	r3, r3, #2
 732 000e 1360     		str	r3, [r2]
 507:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 508:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 509:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 40


 733              		.loc 1 509 3
 734 0010 064B     		ldr	r3, .L45+4
 735 0012 1B69     		ldr	r3, [r3, #16]
 736 0014 054A     		ldr	r2, .L45+4
 737 0016 43F00403 		orr	r3, r3, #4
 738 001a 1361     		str	r3, [r2, #16]
 510:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 511:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
 512:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #if defined ( __CC_ARM)
 513:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __force_stores();
 514:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** #endif
 515:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 516:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   __WFI();
 739              		.loc 1 516 3
 740              		.syntax unified
 741              	@ 516 "./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c" 1
 742 001c 30BF     		wfi
 743              	@ 0 "" 2
 517:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 744              		.loc 1 517 1
 745              		.thumb
 746              		.syntax unified
 747 001e 00BF     		nop
 748 0020 BD46     		mov	sp, r7
 749              		.cfi_def_cfa_register 13
 750              		@ sp needed
 751 0022 80BC     		pop	{r7}
 752              		.cfi_restore 7
 753              		.cfi_def_cfa_offset 0
 754 0024 7047     		bx	lr
 755              	.L46:
 756 0026 00BF     		.align	2
 757              	.L45:
 758 0028 00700040 		.word	1073770496
 759 002c 00ED00E0 		.word	-536810240
 760              		.cfi_endproc
 761              	.LFE76:
 763              		.section	.text.HAL_PWR_EnableSleepOnExit,"ax",%progbits
 764              		.align	1
 765              		.global	HAL_PWR_EnableSleepOnExit
 766              		.syntax unified
 767              		.thumb
 768              		.thumb_func
 770              	HAL_PWR_EnableSleepOnExit:
 771              	.LFB77:
 518:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 519:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 520:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 521:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
 522:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 523:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 524:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       Setting this bit is useful when the processor is expected to run only on
 525:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       interruptions handling.         
 526:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 527:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 528:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 529:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 41


 772              		.loc 1 529 1
 773              		.cfi_startproc
 774              		@ args = 0, pretend = 0, frame = 0
 775              		@ frame_needed = 1, uses_anonymous_args = 0
 776              		@ link register save eliminated.
 777 0000 80B4     		push	{r7}
 778              		.cfi_def_cfa_offset 4
 779              		.cfi_offset 7, -4
 780 0002 00AF     		add	r7, sp, #0
 781              		.cfi_def_cfa_register 7
 530:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 531:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 782              		.loc 1 531 3
 783 0004 044B     		ldr	r3, .L48
 784 0006 1B69     		ldr	r3, [r3, #16]
 785 0008 034A     		ldr	r2, .L48
 786 000a 43F00203 		orr	r3, r3, #2
 787 000e 1361     		str	r3, [r2, #16]
 532:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 788              		.loc 1 532 1
 789 0010 00BF     		nop
 790 0012 BD46     		mov	sp, r7
 791              		.cfi_def_cfa_register 13
 792              		@ sp needed
 793 0014 80BC     		pop	{r7}
 794              		.cfi_restore 7
 795              		.cfi_def_cfa_offset 0
 796 0016 7047     		bx	lr
 797              	.L49:
 798              		.align	2
 799              	.L48:
 800 0018 00ED00E0 		.word	-536810240
 801              		.cfi_endproc
 802              	.LFE77:
 804              		.section	.text.HAL_PWR_DisableSleepOnExit,"ax",%progbits
 805              		.align	1
 806              		.global	HAL_PWR_DisableSleepOnExit
 807              		.syntax unified
 808              		.thumb
 809              		.thumb_func
 811              	HAL_PWR_DisableSleepOnExit:
 812              	.LFB78:
 533:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 534:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 535:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 536:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
 537:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 538:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.          
 539:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 540:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 541:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 542:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 813              		.loc 1 542 1
 814              		.cfi_startproc
 815              		@ args = 0, pretend = 0, frame = 0
 816              		@ frame_needed = 1, uses_anonymous_args = 0
 817              		@ link register save eliminated.
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 42


 818 0000 80B4     		push	{r7}
 819              		.cfi_def_cfa_offset 4
 820              		.cfi_offset 7, -4
 821 0002 00AF     		add	r7, sp, #0
 822              		.cfi_def_cfa_register 7
 543:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 544:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 823              		.loc 1 544 3
 824 0004 044B     		ldr	r3, .L51
 825 0006 1B69     		ldr	r3, [r3, #16]
 826 0008 034A     		ldr	r2, .L51
 827 000a 23F00203 		bic	r3, r3, #2
 828 000e 1361     		str	r3, [r2, #16]
 545:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 829              		.loc 1 545 1
 830 0010 00BF     		nop
 831 0012 BD46     		mov	sp, r7
 832              		.cfi_def_cfa_register 13
 833              		@ sp needed
 834 0014 80BC     		pop	{r7}
 835              		.cfi_restore 7
 836              		.cfi_def_cfa_offset 0
 837 0016 7047     		bx	lr
 838              	.L52:
 839              		.align	2
 840              	.L51:
 841 0018 00ED00E0 		.word	-536810240
 842              		.cfi_endproc
 843              	.LFE78:
 845              		.section	.text.HAL_PWR_EnableSEVOnPend,"ax",%progbits
 846              		.align	1
 847              		.global	HAL_PWR_EnableSEVOnPend
 848              		.syntax unified
 849              		.thumb
 850              		.thumb_func
 852              	HAL_PWR_EnableSEVOnPend:
 853              	.LFB79:
 546:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 547:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 548:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 549:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Enables CORTEX M3 SEVONPEND bit. 
 550:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
 551:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 552:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 553:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 554:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 555:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 854              		.loc 1 555 1
 855              		.cfi_startproc
 856              		@ args = 0, pretend = 0, frame = 0
 857              		@ frame_needed = 1, uses_anonymous_args = 0
 858              		@ link register save eliminated.
 859 0000 80B4     		push	{r7}
 860              		.cfi_def_cfa_offset 4
 861              		.cfi_offset 7, -4
 862 0002 00AF     		add	r7, sp, #0
 863              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 43


 556:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 557:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 864              		.loc 1 557 3
 865 0004 044B     		ldr	r3, .L54
 866 0006 1B69     		ldr	r3, [r3, #16]
 867 0008 034A     		ldr	r2, .L54
 868 000a 43F01003 		orr	r3, r3, #16
 869 000e 1361     		str	r3, [r2, #16]
 558:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 870              		.loc 1 558 1
 871 0010 00BF     		nop
 872 0012 BD46     		mov	sp, r7
 873              		.cfi_def_cfa_register 13
 874              		@ sp needed
 875 0014 80BC     		pop	{r7}
 876              		.cfi_restore 7
 877              		.cfi_def_cfa_offset 0
 878 0016 7047     		bx	lr
 879              	.L55:
 880              		.align	2
 881              	.L54:
 882 0018 00ED00E0 		.word	-536810240
 883              		.cfi_endproc
 884              	.LFE79:
 886              		.section	.text.HAL_PWR_DisableSEVOnPend,"ax",%progbits
 887              		.align	1
 888              		.global	HAL_PWR_DisableSEVOnPend
 889              		.syntax unified
 890              		.thumb
 891              		.thumb_func
 893              	HAL_PWR_DisableSEVOnPend:
 894              	.LFB80:
 559:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 560:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 561:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 562:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief Disables CORTEX M3 SEVONPEND bit. 
 563:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
 564:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.         
 565:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 566:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 567:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 568:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 895              		.loc 1 568 1
 896              		.cfi_startproc
 897              		@ args = 0, pretend = 0, frame = 0
 898              		@ frame_needed = 1, uses_anonymous_args = 0
 899              		@ link register save eliminated.
 900 0000 80B4     		push	{r7}
 901              		.cfi_def_cfa_offset 4
 902              		.cfi_offset 7, -4
 903 0002 00AF     		add	r7, sp, #0
 904              		.cfi_def_cfa_register 7
 569:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 570:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 905              		.loc 1 570 3
 906 0004 044B     		ldr	r3, .L57
 907 0006 1B69     		ldr	r3, [r3, #16]
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 44


 908 0008 034A     		ldr	r2, .L57
 909 000a 23F01003 		bic	r3, r3, #16
 910 000e 1361     		str	r3, [r2, #16]
 571:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 911              		.loc 1 571 1
 912 0010 00BF     		nop
 913 0012 BD46     		mov	sp, r7
 914              		.cfi_def_cfa_register 13
 915              		@ sp needed
 916 0014 80BC     		pop	{r7}
 917              		.cfi_restore 7
 918              		.cfi_def_cfa_offset 0
 919 0016 7047     		bx	lr
 920              	.L58:
 921              		.align	2
 922              	.L57:
 923 0018 00ED00E0 		.word	-536810240
 924              		.cfi_endproc
 925              	.LFE80:
 927              		.section	.text.HAL_PWR_PVD_IRQHandler,"ax",%progbits
 928              		.align	1
 929              		.global	HAL_PWR_PVD_IRQHandler
 930              		.syntax unified
 931              		.thumb
 932              		.thumb_func
 934              	HAL_PWR_PVD_IRQHandler:
 935              	.LFB81:
 572:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 573:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 574:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 575:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 576:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 577:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 578:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 579:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 580:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
 581:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 936              		.loc 1 581 1
 937              		.cfi_startproc
 938              		@ args = 0, pretend = 0, frame = 0
 939              		@ frame_needed = 1, uses_anonymous_args = 0
 940 0000 80B5     		push	{r7, lr}
 941              		.cfi_def_cfa_offset 8
 942              		.cfi_offset 7, -8
 943              		.cfi_offset 14, -4
 944 0002 00AF     		add	r7, sp, #0
 945              		.cfi_def_cfa_register 7
 582:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* Check PWR exti flag */
 583:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 946              		.loc 1 583 6
 947 0004 064B     		ldr	r3, .L62
 948 0006 5B69     		ldr	r3, [r3, #20]
 949 0008 03F48033 		and	r3, r3, #65536
 950              		.loc 1 583 5
 951 000c 002B     		cmp	r3, #0
 952 000e 05D0     		beq	.L61
 584:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   {
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 45


 585:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* PWR PVD interrupt user callback */
 586:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     HAL_PWR_PVDCallback();
 953              		.loc 1 586 5
 954 0010 FFF7FEFF 		bl	HAL_PWR_PVDCallback
 587:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 588:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     /* Clear PWR Exti pending bit */
 589:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 955              		.loc 1 589 5
 956 0014 024B     		ldr	r3, .L62
 957 0016 4FF48032 		mov	r2, #65536
 958 001a 5A61     		str	r2, [r3, #20]
 959              	.L61:
 590:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   }
 591:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 960              		.loc 1 591 1
 961 001c 00BF     		nop
 962 001e 80BD     		pop	{r7, pc}
 963              	.L63:
 964              		.align	2
 965              	.L62:
 966 0020 00040140 		.word	1073808384
 967              		.cfi_endproc
 968              	.LFE81:
 970              		.section	.text.HAL_PWR_PVDCallback,"ax",%progbits
 971              		.align	1
 972              		.weak	HAL_PWR_PVDCallback
 973              		.syntax unified
 974              		.thumb
 975              		.thumb_func
 977              	HAL_PWR_PVDCallback:
 978              	.LFB82:
 592:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** 
 593:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** /**
 594:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 595:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   * @retval None
 596:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   */
 597:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** __weak void HAL_PWR_PVDCallback(void)
 598:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** {
 979              		.loc 1 598 1
 980              		.cfi_startproc
 981              		@ args = 0, pretend = 0, frame = 0
 982              		@ frame_needed = 1, uses_anonymous_args = 0
 983              		@ link register save eliminated.
 984 0000 80B4     		push	{r7}
 985              		.cfi_def_cfa_offset 4
 986              		.cfi_offset 7, -4
 987 0002 00AF     		add	r7, sp, #0
 988              		.cfi_def_cfa_register 7
 599:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****   /* NOTE : This function Should not be modified, when the callback is needed,
 600:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****             the HAL_PWR_PVDCallback could be implemented in the user file
 601:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c ****    */ 
 602:./Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c **** }
 989              		.loc 1 602 1
 990 0004 00BF     		nop
 991 0006 BD46     		mov	sp, r7
 992              		.cfi_def_cfa_register 13
 993              		@ sp needed
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 46


 994 0008 80BC     		pop	{r7}
 995              		.cfi_restore 7
 996              		.cfi_def_cfa_offset 0
 997 000a 7047     		bx	lr
 998              		.cfi_endproc
 999              	.LFE82:
 1001              		.text
 1002              	.Letext0:
 1003              		.file 3 "c:\\st\\stm32cubeide_1.10.1\\stm32cubeide\\plugins\\com.st.stm32cube.ide.mcu.externaltool
 1004              		.file 4 "c:\\st\\stm32cubeide_1.10.1\\stm32cubeide\\plugins\\com.st.stm32cube.ide.mcu.externaltool
 1005              		.file 5 "Drivers/CMSIS/Include/core_cm3.h"
 1006              		.file 6 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 1007              		.file 7 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
 1008              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_pwr.h"
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 47


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f1xx_hal_pwr.c
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:18     .text.PWR_OverloadWfe:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:23     .text.PWR_OverloadWfe:0000000000000000 PWR_OverloadWfe
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:60     .text.HAL_PWR_DeInit:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:66     .text.HAL_PWR_DeInit:0000000000000000 HAL_PWR_DeInit
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:102    .text.HAL_PWR_DeInit:0000000000000024 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:107    .text.HAL_PWR_EnableBkUpAccess:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:113    .text.HAL_PWR_EnableBkUpAccess:0000000000000000 HAL_PWR_EnableBkUpAccess
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:142    .text.HAL_PWR_EnableBkUpAccess:0000000000000014 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:147    .text.HAL_PWR_DisableBkUpAccess:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:153    .text.HAL_PWR_DisableBkUpAccess:0000000000000000 HAL_PWR_DisableBkUpAccess
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:182    .text.HAL_PWR_DisableBkUpAccess:0000000000000014 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:187    .text.HAL_PWR_ConfigPVD:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:193    .text.HAL_PWR_ConfigPVD:0000000000000000 HAL_PWR_ConfigPVD
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:315    .text.HAL_PWR_ConfigPVD:00000000000000b4 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:321    .text.HAL_PWR_EnablePVD:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:327    .text.HAL_PWR_EnablePVD:0000000000000000 HAL_PWR_EnablePVD
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:356    .text.HAL_PWR_EnablePVD:0000000000000014 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:361    .text.HAL_PWR_DisablePVD:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:367    .text.HAL_PWR_DisablePVD:0000000000000000 HAL_PWR_DisablePVD
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:396    .text.HAL_PWR_DisablePVD:0000000000000014 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:401    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:407    .text.HAL_PWR_EnableWakeUpPin:0000000000000000 HAL_PWR_EnableWakeUpPin
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:466    .text.HAL_PWR_EnableWakeUpPin:0000000000000034 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:471    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:477    .text.HAL_PWR_DisableWakeUpPin:0000000000000000 HAL_PWR_DisableWakeUpPin
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:535    .text.HAL_PWR_DisableWakeUpPin:0000000000000034 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:540    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:546    .text.HAL_PWR_EnterSLEEPMode:0000000000000000 HAL_PWR_EnterSLEEPMode
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:613    .text.HAL_PWR_EnterSLEEPMode:0000000000000034 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:618    .text.HAL_PWR_EnterSTOPMode:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:624    .text.HAL_PWR_EnterSTOPMode:0000000000000000 HAL_PWR_EnterSTOPMode
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:703    .text.HAL_PWR_EnterSTOPMode:000000000000005c $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:709    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:715    .text.HAL_PWR_EnterSTANDBYMode:0000000000000000 HAL_PWR_EnterSTANDBYMode
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:758    .text.HAL_PWR_EnterSTANDBYMode:0000000000000028 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:764    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:770    .text.HAL_PWR_EnableSleepOnExit:0000000000000000 HAL_PWR_EnableSleepOnExit
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:800    .text.HAL_PWR_EnableSleepOnExit:0000000000000018 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:805    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:811    .text.HAL_PWR_DisableSleepOnExit:0000000000000000 HAL_PWR_DisableSleepOnExit
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:841    .text.HAL_PWR_DisableSleepOnExit:0000000000000018 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:846    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:852    .text.HAL_PWR_EnableSEVOnPend:0000000000000000 HAL_PWR_EnableSEVOnPend
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:882    .text.HAL_PWR_EnableSEVOnPend:0000000000000018 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:887    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:893    .text.HAL_PWR_DisableSEVOnPend:0000000000000000 HAL_PWR_DisableSEVOnPend
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:923    .text.HAL_PWR_DisableSEVOnPend:0000000000000018 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:928    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 $t
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:934    .text.HAL_PWR_PVD_IRQHandler:0000000000000000 HAL_PWR_PVD_IRQHandler
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:977    .text.HAL_PWR_PVDCallback:0000000000000000 HAL_PWR_PVDCallback
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:966    .text.HAL_PWR_PVD_IRQHandler:0000000000000020 $d
C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s:971    .text.HAL_PWR_PVDCallback:0000000000000000 $t
                           .group:0000000000000000 wm4.0.cb5f01749778df26340c4505df3d34d0
                           .group:0000000000000000 wm4.stm32f1xx_hal_conf.h.21.98635006afa9a018cfa5e0632ed4968b
                           .group:0000000000000000 wm4.stm32f1xx.h.39.208bb8a61c892b7c37d899c49a031330
ARM GAS  C:\Users\ULTIMA~1\AppData\Local\Temp\cczF2gSa.s 			page 48


                           .group:0000000000000000 wm4.stm32f103xb.h.38.ec967d5ad9d3269cb0788eebda048e38
                           .group:0000000000000000 wm4._newlib_version.h.4.bfdf54b0af045d4a71376ae00f63a22c
                           .group:0000000000000000 wm4.features.h.33.318b64d71e0957639cfb30f1db1f7ec8
                           .group:0000000000000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:0000000000000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:0000000000000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:0000000000000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:0000000000000000 wm4.cmsis_version.h.32.4d5822004c01a829a975260e854b5f8e
                           .group:0000000000000000 wm4.core_cm3.h.66.fc46cac19810db8f98d67da7ef88f42c
                           .group:0000000000000000 wm4.cmsis_gcc.h.26.4f5798e999d5690b80e6ded3ecc94b37
                           .group:0000000000000000 wm4.core_cm3.h.127.f4474120f1a7524deb56f9d74ff175da
                           .group:0000000000000000 wm4.stm32f103xb.h.573.10249aa7473ca93be896fed94046a725
                           .group:0000000000000000 wm4.stm32f1xx.h.162.96b09079a093c34dbd7f0b85cbd0ddee
                           .group:0000000000000000 wm4.stm32_hal_legacy.h.23.91ba5b544a4c2be2620a1e7ff0049e10
                           .group:0000000000000000 wm4.stddef.h.39.144cf5ddcd53cbfdac30259dc1a6c87f
                           .group:0000000000000000 wm4.stm32f1xx_hal_def.h.57.18d01ce1aa74e9fb44dbf16f821a574a
                           .group:0000000000000000 wm4.stm32f1xx_hal_rcc.h.95.21591bbc513aaa813c0b8640c3b32517
                           .group:0000000000000000 wm4.stm32f1xx_hal_rcc_ex.h.22.8763f99bc1e3e2dcf0febe9161d81b37
                           .group:0000000000000000 wm4.stm32f1xx_hal_rcc.h.1202.f8e5f9e0cf4eef7840facf5396029056
                           .group:0000000000000000 wm4.stm32f1xx_hal_gpio.h.22.fa638d688dcc57ca806fe6a7831b0d04
                           .group:0000000000000000 wm4.stm32f1xx_hal_gpio_ex.h.22.51a50ef3512cd78017ce666a32d364bf
                           .group:0000000000000000 wm4.stm32f1xx_hal_gpio.h.263.f5ebf2f545ade59412ab9261c8e35dc4
                           .group:0000000000000000 wm4.stm32f1xx_hal_exti.h.22.e26491d042c8079c3ca67eca341af862
                           .group:0000000000000000 wm4.stm32f1xx_hal_dma.h.22.3c14338534886827bf3aeaa2a7f412a1
                           .group:0000000000000000 wm4.stm32f1xx_hal_dma_ex.h.22.001ac4d7f81ccbdcae49bd65c13858c8
                           .group:0000000000000000 wm4.stm32f1xx_hal_dma.h.409.cafcd2cfe701091535636be537c18293
                           .group:0000000000000000 wm4.stm32f1xx_hal_cortex.h.22.b5f4174bb6a50d95405567b8f50e0900
                           .group:0000000000000000 wm4.stm32f1xx_hal_flash.h.22.5cea9a7210e6315b41724b47b5fdf203
                           .group:0000000000000000 wm4.stm32f1xx_hal_flash_ex.h.22.d4e19c21f2a86fa2f8ec2c2d5f1ab2af
                           .group:0000000000000000 wm4.stm32f1xx_hal_pwr.h.22.3438c476faafc3240bf146f143df3fcd
                           .group:0000000000000000 wm4.stm32f1xx_hal_tim.h.22.a16e206564e97dbace9faae59a0d6008
                           .group:0000000000000000 wm4.stm32f1xx_hal_uart.h.22.5f7992e497faa36aa98f09f7214f4dbb
                           .group:0000000000000000 wm4.stm32f1xx_hal.h.88.91065c0692bed6019c34f1e9c00589fd

NO UNDEFINED SYMBOLS
